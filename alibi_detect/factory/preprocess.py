from alibi_detect.cd.pytorch import preprocess_drift as preprocess_drift_torch
from alibi_detect.cd.tensorflow import preprocess_drift as preprocess_drift_tf
from functools import partial
import logging
from torch import device as torch_device
import torch.nn as nn
from tensorflow.keras import Model as KerasModel
from typing import Callable, Optional

logger = logging.getLogger(__name__)


# TODO - pytorch, embedding, tokenizer etc
def load_preprocessor(cfg: dict,
                      backend: Optional[str] = 'tensorflow',
                      verbose: Optional[bool] = False) -> Optional[Callable]:
    """
    This function builds a preprocess_fn from the preprocess dict in a detector config dict. The dict format is
    expected to match that generated by serialize_preprocess in alibi_detect.utils.saving. The model, tokenizer and
    preprocess_batch_fn are expected to be already resolved.
    """
    kwargs = cfg.get('kwargs', {})
    preprocess_fn = cfg.get('preprocess_fn')

    # TODO - Deal with embeddings i.e. model=embedding if no model. If both model = model(input_layer=embedding)
    # If string...
    if isinstance(preprocess_fn, str):
        # If still a str, check if this refers to in-built preprocess_drift function
        if preprocess_fn == 'preprocess_drift':
            if 'model' not in kwargs:
                raise ValueError("The 'model' field must be specified when 'preprocess_fn'='preprocess_drift'")
            if backend == 'tensorflow':
                preprocess_fn = preprocess_drift_tf
                if not isinstance(kwargs['model'], KerasModel):
                    raise ValueError('The specified model is not a compatible tensorflow model.')
            elif backend == 'pytorch':
                preprocess_fn = preprocess_drift_torch
                if not isinstance(kwargs['model'], (nn.Module, nn.Sequential)):
                    raise ValueError('The specified model is not a compatible pytorch model.')
                if 'device' in cfg:
                    device = torch_device(kwargs['device'])
                    kwargs.update({'model': kwargs['model'].to(device)})  # TODO - needs testing
                    kwargs.update({'device': device})

        else:
            # If still a str, but not 'preprocess_drift', resolution of local filepath must have failed
            raise ValueError("If preprocess_fn is a str, it must either be a filepath to a .dill file, "
                             "or 'preprocess_drift'")

    # If already function, assume preprocess_fn is an already resolved function (TODO: tighten this?)
    elif callable(preprocess_fn):
        pass
    else:
        logger.warning('Unable to process preprocess_fn. No preprocessing function is defined.')
        return None

    return partial(preprocess_fn, **kwargs)
